when i do import Vue from 'vue' in store.ts, Vue loads fine in webpack/web  . . .. but not in ava-ts tests . . .

-----





DONE get knawledgeMap DI working
DONE check if knawledemap mounting can work
GOAL get treecomponent official mounting working so we can test with props



studyMenu spec test with a method doesn't work. this is probably because there is a vue warning stating template or render function not defined....
	. . . . but we get that same warning on knawledgeMap2.spec.ts . . . where a test with a method DOES work

[1] lets try cloning knawledgemap into a different folder and running the same spec.
	-- so it worked
	-- then i replaced its innards with study menus
	-- still worked

[2] lets replace knawledgemapclone's innards with treeComponents innards
	-- works great!
[3] lets slowly rename everything from knawledgemapclone to treeComponet. . .. tree3Component haha?



==========
1/17/2018
// FINISH tooltipRenderer/opener so that store can compile so that I can test partial dependency injection tool
//DONE Write Partial Dependency Injection tool
// [] get tooltipRenderer.spec.ts working
	- get store.watch working
// Rewrite a bunch of the global store tests to use the partial inject tool
// Make tooltipRenderer and tooltipOpener classes
// Get tooltip opener to pass in correct contentUserId
// Get app to generate a random initial userId
// Get correct contentUserId to be sent to the contentuserstoreMutation center
// TODO: if contentUser does not yet exist in the DB create it.
mutations[MUTATION_NAMES.ADD_CONTENT_INTERACTION]


GET A DEV and PRODUCTION DATABASE GOING

======
so color needs to be determined from ProficiencyOutput

proficiencyInput by default gets set to contentUserData.proficiency or PROFICIENCIES.UNKNOWN if contentUserDataLoaded does not exist
	-it is not a computed Property though . .. because it needs to get set by the proficiency-selector-component

proficiencyInput model is synced with proficiencySelector
	proficiencySelector onChange triggers ProficiencySelected event, which will call a mutation that fluxes through the system and updates the contentUserData in sigmaNode that tooltipRenderer uses to pass props into the vue template.
	so as designed right now, contentUserData will stay null/undefined after user interactions if it started off null, unless the user closes the vue template and rerenders it from the updatedSigmaNode




==================junkyard====================
so tooltipOpener needs to use tooltips to call this.tooltips.open. it also needs to have a getTooltipsConfig method

well getTooltipsConfig method needs a reference to a renderer method, so it would make sence if it were a method on the getTooltipRenderer class, or if getTooltipsConfig had a renderer argument

well getTooltipRenderer doesn't actually depend on anything. so we'll create taht first


    private getTooltipsConfig() {
        const tooltipsConfig = {
            node: [
                {
                    show: 'rightClickNode',
                    cssClass: 'sigma-tooltip',
                    position: 'center',
                    template: '',
                    renderer: this.renderer
                }],
        };
        return tooltipsConfig
    }

